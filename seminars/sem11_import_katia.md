# Импорт и создание модулей

## Содержание

* [Импорт модулей стандартной библиотеки](#импорт-модулей-стандартной-библиотеки)
  * [Импорт нескольких модулей](#импорт-нескольких-модулей)
  * [Инструкция from](#инструкция-from)
  * [Использование псевдонимов](#использование-псевдонимов)
  
* [Создание своего модуля](#создание-своего-модуля)
* [Запуск скрипта](#запуск-скрипта)
* [Задача: составление анаграмм](#задача-составление-анаграмм)

## Импорт модулей стандартной библиотеки

Питон включает в себя обширную библиотеку модулей, в которых реализовано множество полезных функций. В этом курсе мы применяли и еще будем применять такие модули как [`re`](https://docs.python.org/3/library/re.html) для регулярных выражений, [`collections`](https://docs.python.org/3/library/collections.html), содержащий множество удобных структур данных, [`os`](https://docs.python.org/3/library/os.html) и [`shutil`](https://docs.python.org/3/library/shutil.html) для управления файлами и папками, [`sys`](https://docs.python.org/3/library/sys.html) для взаимодействия с интерпретатором (всегда доступен специфичен для системы).

Правило хорошего тона — импортировать модули вначале вашей программы, до любого другого кода и функций и пропускать одну строку перед кодом по PEP-8.

Для использования модуля его нужно импортировать — попросить питон загрузить его и сделать его функции доступными для использования. Импорт осуществляется с помощью оператора `import`. Например, модуль [`random`](https://docs.python.org/3/library/random.html) используется для генерации "случайных" чисел.

```python
import random

print(random.randint(0, 5))  # выводит случайное целое число между 0 и 5 включительно
print(random.choice('abcdef'))  # выберает случайный элемент коллекции
print(random.random())  # Выводит случайное число на полуинтервале [0, 1)


2
c
0.9131300358342321
```


Ещё один пример: модуль `math`, содержащий различные математические функции и константы.

```python
print(math.cos(0))  # ошибка, модуль ещё не импортирован

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[4], line 1
----> 1 print(math.cos(0))

NameError: name 'math' is not defined
```

```python
import math

print(math.cos(0))
print(math.asin(1))
print(math.e)


1.0
1.5707963267948966
2.718281828459045
```

### Импорт нескольких модулей

Модули можно импортировать в одну строчку через запятую, если требуется использовать несколько, либо можно писать каждый импорт на новой строчке. Некоторая проблема заключается в том, что по PEP-8 первый вариант через запятую не одобряется, но знать не лишнее.

```python
import random, math

print(math.sqrt(random.randint(0, 5)))


2.23606797749979
```

Лучше все же так:

```python
import random
import math

print(math.sqrt(random.randint(0, 5)))


2.0
```

### Инструкция from

Как вы могли заметить, в модуле бывает много разных функций, а вам нужно использовать только что-то одно (и, например, использовать много раз), тогда проще импортировать какую-то определенную функцию из этого модуля и (1) чуть-чуть сэкономить память, (2) **упростить синтаксис**. Тогда синтаксис импорта будет следующий:

```python
from math import ceil, floor

print(ceil(145.3))
print(floor(145.6))


146
145
```

Также можно импортировать из модуля всё. То есть **все функции, переменные и классы**. Тогда нам не нужно каждый раз писать название модуля.

```python
from math import *

print(sqrt(144))
print(pi)


12.0
3.141592653589793
```

<div class="alert alert-danger font-weight-bold">
Однако это очень плохая практика, так как в двух разных модулях могут быть одинаковые функции и при импорте вы просто не будете знать, какую используете. Подробнее на эту проблему посмотрим ниже.
</div>****

### Использование псевдонимов

По-английски называется *aliasing*. Если вы не хотите писать название модуля / функции каждый раз, когда используете их, вы можете импортировать их под псевдонимом с помощью `as`:

```python
import math as m

print(m.factorial(5))


120
```

Или даже так:

```python
from math import factorial as fact

print(fact(5))


120
```

## Создание своего модуля

Любой PY-файл с исходным кодом на Python $-$ это модуль! Это значит, что любая программа может выступать в роли модуля для другой и импортироваться.

Давайте напишем скрипт с парой функций и импортируем эти функции в другую программу.

Создадим программу `**mymodule.py**`:

```python
# mymodule.py
def avg(numbers: list[int | float]) -> float:
    '''
    Функция, которая возвращает среднее от списка.
    '''
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)


def myfactorial(n: int) -> int | str:
    '''
    Функция, которая возвращает n! (факториал от n).
    '''
    if n == 1:
        return n
    elif n < 1:
        return "NA"
    else:
        return n * myfactorial(n - 1)
```

В ней мы прописали две математические функции: среднее и факториал. Предположим теперь мы хотим воспользоваться ими в какой-нибудь другой программе. Тогда мы положим эти два файла в **одну директорию**, чтобы импорт работал. И в результате мы сможем ипмортировать эти функции в новую программу.

```python
# или from mymodule import avg, myfactorial
import mymodule

n = input("Введите число: ")
my_list = [1] * (int(n) // 2) + [2] * (int(n) // 2)

print(mymodule.avg(my_list))
print(mymodule.myfactorial(int(n)))
```

Добавим чуть-чуть в наш файл `**mymodule.py**`:

```python
# mymodule.py
my_favourite_number = 13  # глобальная переменная с любимым числом

def avg(numbers: list[int | float]) -> float:
    '''
    Функция, которая возвращает среднее от списка.
    '''
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)


def myfactorial(n: int) -> int | str:
    '''
    Функция, которая возвращает n! (факториал от n).
    '''
    if n == 1:
        return n
    elif n < 1:
        return "NA"
    else:
        return n * myfactorial(n - 1)
```

Важно сказать, что каждый модуль / пакет импортируется лишь один раз за сессию, поэтому, чтобы изменения внеслись, иногда надо перезапустить интерпретатор или сделать так:

```python
import importlib

importlib.reload(mymodule)
```

Все, теперь мы можем сделать так:

```python
from mymodule import my_favourite_number

print(my_favourite_number)
```

Теперь должно стать чуть понятнее, почему мы можем не хотеть делать `from mymodule import *`...

А сейчас откатимся на пару шагов назад. Чем импорт библиотеки отличается от импорта встроенного модуля? На самом деле, ничем. 

Мы можем легко найти папку где лежит такой же PY-файл (на самом деле, он спрятан там же, где спрятан сам питон):

```python
import pprint

print(pprint.__file__)
```

И тут важна приоритетность. Если вы попытаетесь создать файл `pprint.py` в своей директории, то приоритетнее все еще будет тот, что лежит "глубоко".

## Запуск скрипта

Надеюсь, ни для кого не секрет, что мы можем записать в файл `testmymodule.py` что-то подобное:

```python
# testmymodule.py
import mymodule

n = input("Введите число: ")
my_list = [1] * (int(n) // 2) + [2] * (int(n) // 2)

print(mymodule.avg(my_list))
print(mymodule.myfactorial(int(n)))
```

А потом можем запустить наш PY-скрипт в терминале так.

```sh
python testmymodule.py
```

А что если мы не хотим создавать для этого отдельный файл, а хотим через терминал проверить? Без проблем!

Можем добавить в `mymodule.py` что-то подобное:

```python
# mymodule.py
if __name__ == "__main__":
    n = int(sys.argv[1])
    
    my_list = [1] * (int(n) // 2) + [2] * (int(n) // 2)

    print(myfactorial(n))
    print(avg(my_list))
```

И теперь запускать через терминал так:

```sh
python mymodule.py 5
```

А что вообще сейчас произошло..?

На самом деле, мы просто явно указали точку входа (может быть сделано только в модулях). Для этого используется специальная переменная `__name__`, в которой содержится наименование текущего модуля или пакета. Если мы явно передали текущий модуль на исполнение (например, в терминал), то он называется `__main__` независимо от названия файла (наследие предков...).

## Пакеты

Если у нас несколько модулей, то мы можем их организовать в один пакет (*package*). Пример ниже:

```
seminars/                       Пакет верхнего уровня
      __init__.py               Инициализация пакета seminars
      py_one/                   Подпакет с файлами для семинаров 1-го курса
              __init__.py
              mymodule.py
              fibonacci.py
              hanoi.py
              recursion.py
              ...
      py_two/                   Подпакет с файлами для семинаров 2-го курса
              __init__.py
              morphology.py
              my_flask.py
              tg_bot.py
              ...
```

Файлы `__init.py__` $-$ это внутренняя кухня питона. В дефолтном случае они нужны для инициализации каждый своего (под)пакета и могут быть пустыми. В более сложном случае в них может быть прописан `__all__`, который и отвечает за установку в случае `from seminars.py_one import *`. Например, так:

```python
# __init__.py в py_one
__all__ = ["fibonacci", "hanoi"]
```

Можно импортировать отдельные модули из пакета, но просто импортировать пакет нельзя:

```python
# import seminars - это бред
import seminars.py_one.mymodule

print(seminars.py_one.mymodule.myfactorial(10))
```

Или же:

```python
from seminars.py_one import mymodule

print(mymodule.myfactorial(10))
```

Если нам надо как-то подниматься между папками, то для этого тоже нужны `.`:

```python
# my_flask.py 
from . import morphology
from ..py_one import mymodule
```

## Задача: составление анаграмм

В качестве примера использования функций и модуля стандартной библиотеки `random` рассмотрим задачу составления анаграмм. В качестве входного файла будем использовать любой текст, из которого мы выберем слова. Пусть текст находится в файле `text.txt` и имеет следующее содержание (из Яндекс.Рефератов):

```
Субъект вызывает мелодический импульс. Пласт параллельно понимает понимающий
эриксоновский гипноз, следовательно тенденция к конформизму связана с менее
низким интеллектом. Дифференциация, по определению, дает звукорядный
бихевиоризм.
```

Задача состоит в том, что необходимо составить файл формата [TSV](https://ru.wikipedia.org/wiki/TSV), состоящий из 4 колонок: слово из файла и три его случайных анаграммы. Для простоты анаграммы могут совпадать с самим словом или друг с другом. В итоге требуется получить файл `table.tsv`, который будет начинаться следующим образом:

```
субъект	ъсукебт	кутесъб	кеубътс
вызывает	езтавыыв	аыезыввт	ывеаывзт
мелодический	скйчмеелидио	диимечеслйок	мкееийлчосид
импульс	млсупьи	уьмипсл	льмпиус
пласт	сатпл	таслп	тпалс
...
```


# Домашнее задание

Пусть какая-то функция получает на вход список из 30 случайных целых чисел от 0 до 100, сгенерированных с помощью модуля random. В вариантах описана функция.

+1 балл для всех: ответьте коротко на вопрос "Почему модуль random на самом деле НЕ генерирует случайные числа?"

1. Функция берёт два случайных числа из этого списка (с помощью модуля random) и считает по ним количество всевозможных сочетаний этих чисел с точки зрения теории вероятности, С из n по k (использовать функцию из модуля math -- factorial). Количество сочетаний (в формате float) печатается. k должно быть меньше n

2. Функция возвращает произведение значений списка. Нужно пользоваться модулем math. Руководствоваться надо тем, что exp(log(a) + log(b)) = a * b

3. Функция возвращает строку из 30 букв. Список, полученный на вход, задает порядок букв в строке по номеру буквы в алфавите.

4. Функция берёт из списка 4 случайных числа, условно принимает их за две точки в двумерном пространстве и возвращает евклидово расстояние между этими точками. Использовать модули random и math.

5. Функция перемешивает список с помощью random.shuffle(), сравнивает его с исходным списком и возвращает количество индексов, значение элемента по которым поменялось. Запустите функцию в цикле 100 раз и напечатайте в скольки процентов случаев меняются все элементы списка.

6. Функция возвращает среднее геометрическое списка. Вомпользуйтесь модулем math. Отдельно вне функции покажите, что ее результат лежит между минимальным и максимальным значениями списка для 20 случаев. (Для это нужно на каждой итерации генерировать подаваемый на вход список заново)

7. Функция возвращает среднее арифметическое элементов списка, округлённое вверх. Используйте модуль math.
